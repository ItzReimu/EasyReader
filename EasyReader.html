
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {
background-color: white; /* Ensure the iframe has a white background */
}


</style>
</head>
<body>
    <!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>EasyReader</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
:root {
--primary-color: #4f46e5;
--secondary-color: #6366f1;
--background-light: #f8fafc;
--background-dark: #0f172a;
--text-light: #334155;
--text-dark: #e2e8f0;
--card-light: #ffffff;
--card-dark: #1e293b;
--border-light: #e2e8f0;
--border-dark: #334155;
--success-color: #10b981;
--warning-color: #f59e0b;
--error-color: #ef4444;
}
body {
font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
background: var(--background-light);
color: var(--text-light);
transition: all 0.3s ease;
overflow-x: hidden;
}
body.dark {
background: var(--background-dark);
color: var(--text-dark);
}

/* é¡¶éƒ¨å¯¼èˆªæ  */
.navbar {
position: fixed;
top: 0;
left: 0;
right: 0;
height: 60px;
background: var(--card-light);
border-bottom: 1px solid var(--border-light);
backdrop-filter: blur(20px);
display: flex;
align-items: center;
justify-content: space-between;
padding: 0 20px;
z-index: 1000;
transition: all 0.3s ease;
}
body.dark .navbar {
background: rgba(15, 23, 42, 0.9);
border-bottom-color: var(--border-dark);
}
.logo {
font-size: 20px;
font-weight: 700;
color: var(--primary-color);
display: flex;
align-items: center;
gap: 8px;
}
.nav-controls {
display: flex;
align-items: center;
gap: 15px;
}
.control-btn {
background: none;
border: none;
padding: 8px 12px;
border-radius: 8px;
cursor: pointer;
color: var(--text-light);
transition: all 0.2s ease;
font-size: 14px;
display: flex;
align-items: center;
gap: 5px;
}
body.dark .control-btn {
color: var(--text-dark);
}
.control-btn:hover {
background: rgba(79, 70, 229, 0.1);
color: var(--primary-color);
}

/* ä¸»è¦å†…å®¹åŒºåŸŸ */
.main-container {
margin-top: 60px;
min-height: calc(100vh - 60px);
display: flex;
}

/* ä¾§è¾¹æ  */
.sidebar {
width: 300px;
background: var(--card-light);
border-right: 1px solid var(--border-light);
padding: 20px;
transition: all 0.3s ease;
position: fixed;
height: calc(100vh - 60px);
overflow-y: auto;
transform: translateX(-100%);
z-index: 1000;
}
body.dark .sidebar {
background: var(--card-dark);
border-right-color: var(--border-dark);
}
.sidebar.open {
transform: translateX(0);
}

.file-upload {
border: 2px dashed var(--border-light);
border-radius: 12px;
padding: 30px 20px;
text-align: center;
cursor: pointer;
transition: all 0.3s ease;
margin-bottom: 20px;
}
body.dark .file-upload {
border-color: var(--border-dark);
}
.file-upload:hover {
border-color: var(--primary-color);
background: rgba(79, 70, 229, 0.05);
}
.file-upload input {
display: none;
}

.reading-settings {
background: rgba(79, 70, 229, 0.05);
border-radius: 12px;
padding: 20px;
margin-bottom: 20px;
}
.setting-group {
margin-bottom: 15px;
}
.setting-label {
display: block;
font-size: 14px;
font-weight: 500;
margin-bottom: 8px;
color: var(--text-light);
}
body.dark .setting-label {
color: var(--text-dark);
}
.setting-input {
width: 100%;
padding: 8px 12px;
border: 1px solid var(--border-light);
border-radius: 6px;
background: var(--card-light);
color: var(--text-light);
font-size: 14px;
}
body.dark .setting-input {
background: var(--background-dark);
border-color: var(--border-dark);
color: var(--text-dark);
}
.slider {
-webkit-appearance: none;
width: 100%;
height: 6px;
border-radius: 3px;
background: var(--border-light);
outline: none;
}
body.dark .slider {
background: var(--border-dark);
}
.slider::-webkit-slider-thumb {
-webkit-appearance: none;
width: 18px;
height: 18px;
border-radius: 50%;
background: var(--primary-color);
cursor: pointer;
}

/* æœç´¢ç»“æœæ ·å¼ */
.highlight {
background-color: #fbbf24;
color: #000;
padding: 2px 0;
border-radius: 2px;
}
.search-result-info {
font-size: 12px;
color: #64748b;
margin-top: 5px;
}

/* ç¼–ç çŠ¶æ€æŒ‡ç¤ºå™¨ */
.encoding-status {
display: flex;
align-items: center;
gap: 8px;
padding: 8px 12px;
border-radius: 6px;
font-size: 12px;
font-weight: 500;
margin-top: 8px;
}
.encoding-status.success {
background: rgba(16, 185, 129, 0.1);
color: var(--success-color);
}
.encoding-status.warning {
background: rgba(245, 158, 11, 0.1);
color: var(--warning-color);
}
.encoding-status.error {
background: rgba(239, 68, 68, 0.1);
color: var(--error-color);
}

/* é˜…è¯»åŒºåŸŸ */
.reading-area {
flex: 1;
margin-left: 0;
transition: all 0.3s ease;
}
.reading-area.sidebar-open {
margin-left: 300px;
}
.reader-container {
max-width: 800px;
margin: 0 auto;
padding: 40px 20px;
line-height: 1.8;
font-size: 16px;
}
.chapter-title {
font-size: 28px;
font-weight: 700;
margin-bottom: 30px;
color: var(--primary-color);
text-align: center;
}
.text-content {
background: var(--card-light);
padding: 40px;
border-radius: 16px;
box-shadow: 0 4px 24px rgba(0, 0, 0, 0.06);
margin-bottom: 30px;
white-space: pre-wrap;
word-wrap: break-word;
transition: all 0.3s ease;
}
body.dark .text-content {
background: var(--card-dark);
box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3);
}

/* é˜…è¯»è¿›åº¦æ¡ */
.progress-container {
position: fixed;
bottom: 0;
left: 0;
right: 0;
height: 60px;
background: var(--card-light);
border-top: 1px solid var(--border-light);
display: flex;
align-items: center;
justify-content: space-between;
padding: 0 20px;
z-index: 1000;
}
body.dark .progress-container {
background: rgba(15, 23, 42, 0.9);
border-top-color: var(--border-dark);
}
.progress-bar {
flex: 1;
height: 4px;
background: var(--border-light);
border-radius: 2px;
margin: 0 20px;
position: relative;
cursor: pointer;
}
body.dark .progress-bar {
background: var(--border-dark);
}
.progress-fill {
height: 100%;
background: var(--primary-color);
border-radius: 2px;
transition: width 0.3s ease;
}
.progress-info {
font-size: 14px;
color: var(--text-light);
white-space: nowrap;
}
body.dark .progress-info {
color: var(--text-dark);
}

/* ç©ºçŠ¶æ€ */
.empty-state {
text-align: center;
padding: 80px 20px;
color: #94a3b8;
}
.empty-icon {
font-size: 64px;
margin-bottom: 20px;
}

/* åŠ è½½çŠ¶æ€ */
.loading-spinner {
display: inline-block;
width: 20px;
height: 20px;
border: 2px solid var(--border-light);
border-radius: 50%;
border-top-color: var(--primary-color);
animation: spin 1s ease-in-out infinite;
}
@keyframes spin {
to { transform: rotate(360deg); }
}

/* å“åº”å¼è®¾è®¡ */
@media (max-width: 768px) {
.sidebar {
width: 280px;
}
.reading-area.sidebar-open {
margin-left: 0;
}
.reader-container {
padding: 20px 15px;
}
.text-content {
padding: 20px;
}
.nav-controls .control-btn span {
display: none;
}
}

/* åŠ¨ç”»æ•ˆæœ */
@keyframes fadeIn {
from { opacity: 0; transform: translateY(20px); }
to { opacity: 1; transform: translateY(0); }
}
.text-content {
animation: fadeIn 0.6s ease-out;
}

/* å·¥å…·æç¤º */
.tooltip {
position: relative;
}
.tooltip:hover::after {
content: attr(data-tooltip);
position: absolute;
bottom: 100%;
left: 50%;
transform: translateX(-50%);
background: #1f2937;
color: white;
padding: 6px 12px;
border-radius: 6px;
font-size: 12px;
white-space: nowrap;
z-index: 1001;
}

/* è‡ªåŠ¨æ»šåŠ¨æŒ‡ç¤ºå™¨ */
.auto-scroll-indicator {
position: fixed;
top: 70px;
right: 20px;
background: var(--primary-color);
color: white;
padding: 8px 16px;
border-radius: 20px;
font-size: 12px;
opacity: 0;
transform: translateX(100%);
transition: all 0.3s ease;
z-index: 1000;
}
.auto-scroll-indicator.active {
opacity: 1;
transform: translateX(0);
}

/* é€šçŸ¥æ¶ˆæ¯ */
.notification {
position: fixed;
top: 70px;
left: 50%;
transform: translateX(-50%) translateY(-10px);
padding: 12px 20px;
border-radius: 8px;
font-size: 14px;
font-weight: 500;
z-index: 1001;
opacity: 0;
transition: all 0.3s ease;
max-width: 400px;
text-align: center;
}
.notification.success {
background: var(--success-color);
color: white;
}
.notification.warning {
background: var(--warning-color);
color: white;
}
.notification.error {
background: var(--error-color);
color: white;
}
.notification.show {
opacity: 1;
transform: translateX(-50%) translateY(0);
}

/* é˜…è¯»å†å²é¡¹ */
.history-item {
padding: 10px;
border-radius: 8px;
background: rgba(79, 70, 229, 0.05);
margin-bottom: 10px;
font-size: 14px;
cursor: pointer;
transition: all 0.2s;
}
.history-item:hover {
background: rgba(79, 70, 229, 0.1);
}
.history-filename {
font-weight: 500;
color: var(--primary-color);
}
.history-progress {
font-size: 12px;
color: #64748b;
}

/* è‡ªå®šä¹‰æ¨¡æ€æ¡†é€šç”¨æ ·å¼ */
.resume-modal {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(15, 23, 42, 0.6);
display: flex;
align-items: center;
justify-content: center;
z-index: 2000;
animation: fadeIn 0.3s ease;
}

.resume-modal-content {
background: var(--card-light);
border-radius: 16px;
box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
padding: 24px;
width: 90%;
max-width: 400px;
position: relative;
animation: scaleIn 0.3s ease;
border: 1px solid var(--border-light);
}

body.dark .resume-modal-content {
background: var(--card-dark);
border-color: var(--border-dark);
}

.resume-close-btn {
position: absolute;
top: 12px;
right: 12px;
background: none;
border: none;
font-size: 24px;
color: var(--text-light);
cursor: pointer;
opacity: 0.7;
transition: all 0.2s;
}

.resume-close-btn:hover {
opacity: 1;
transform: scale(1.1);
}

@keyframes scaleIn {
from { transform: scale(0.8); opacity: 0; }
to { transform: scale(1); opacity: 1; }
}
</style>
</head>
<body>

<!-- é¡¶éƒ¨å¯¼èˆªæ  -->
<div class="navbar">
<div class="logo"> ğŸ“š EasyReader </div>
<div class="nav-controls">
<button class="control-btn tooltip" data-tooltip="æ‰“å¼€/å…³é—­è®¾ç½®" onclick="toggleSidebar()">
âš™ï¸ <span>è®¾ç½®</span>
</button>
<button class="control-btn tooltip" data-tooltip="è‡ªåŠ¨æ»šåŠ¨" onclick="toggleAutoScroll()">
â¯ï¸ <span>è‡ªåŠ¨æ»šåŠ¨</span>
</button>
<button class="control-btn tooltip" data-tooltip="å…¨å±æ¨¡å¼" onclick="toggleFullscreen()">
ğŸ“º <span>å…¨å±</span>
</button>
<button class="control-btn tooltip" data-tooltip="æ·±è‰²æ¨¡å¼" onclick="toggleDarkMode()">
ğŸŒ™ <span>æ·±è‰²</span>
</button>
</div>
</div>

<!-- è‡ªåŠ¨æ»šåŠ¨æŒ‡ç¤ºå™¨ -->
<div class="auto-scroll-indicator" id="autoScrollIndicator">
è‡ªåŠ¨æ»šåŠ¨ä¸­... ç‚¹å‡»ä»»æ„ä½ç½®æš‚åœ
</div>

<!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
<div class="main-container">
<!-- ä¾§è¾¹æ  -->
<div class="sidebar" id="sidebar">
<!-- æ–‡ä»¶ä¸Šä¼ åŒºåŸŸ -->
<div class="file-upload" onclick="document.getElementById('fileInput').click()">
<div style="font-size: 32px; margin-bottom: 10px;">ğŸ“„</div>
<div style="font-weight: 600; margin-bottom: 5px;">é€‰æ‹©TXTæ–‡ä»¶</div>
<div style="font-size: 14px; color: #64748b;">ç‚¹å‡»ä¸Šä¼ æˆ–æ‹–æ‹½æ–‡ä»¶åˆ°è¿™é‡Œ</div>
<input type="file" id="fileInput" accept=".txt" onchange="loadFile(event)">
</div>

<!-- ç¼–ç è®¾ç½® -->
<div class="reading-settings">
<h3 style="margin-bottom: 15px; color: var(--primary-color);">ğŸ”§ ç¼–ç è®¾ç½®</h3>
<div class="setting-group">
<label class="setting-label">å½“å‰ç¼–ç </label>
<div id="currentEncoding" class="encoding-status success" style="display: none;">
<span>âœ…</span> <span id="encodingName">è‡ªåŠ¨æ£€æµ‹</span>
</div>
</div>
<div class="setting-group">
<label class="setting-label">æ‰‹åŠ¨é€‰æ‹©ç¼–ç </label>
<select class="setting-input" id="manualEncoding" onchange="reloadWithEncoding()">
<option value="">è‡ªåŠ¨æ£€æµ‹ (æ¨è)</option>
<option value="UTF-8">UTF-8 (Unicode)</option>
<option value="GBK">GBK (ä¸­æ–‡Windows)</option>
<option value="GB2312">GB2312 (ç®€ä½“ä¸­æ–‡)</option>
<option value="GB18030">GB18030 (ä¸­æ–‡æ‰©å±•)</option>
<option value="Big5">Big5 (ç¹ä½“ä¸­æ–‡)</option>
<option value="UTF-16LE">UTF-16LE (Windows Unicode)</option>
<option value="UTF-16BE">UTF-16BE (å¤§ç«¯åºUnicode)</option>
<option value="Shift_JIS">Shift_JIS (æ—¥æ–‡)</option>
<option value="EUC-KR">EUC-KR (éŸ©æ–‡)</option>
<option value="ISO-8859-1">ISO-8859-1 (æ‹‰ä¸æ–‡)</option>
<option value="Windows-1252">Windows-1252 (è¥¿æ¬§)</option>
</select>
</div>
<div class="setting-group">
<small style="color: #64748b; font-size: 12px;">
ğŸ’¡ æç¤ºï¼šå¦‚æœæ–‡å­—æ˜¾ç¤ºä¹±ç ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ­£ç¡®çš„ç¼–ç æ ¼å¼
</small>
</div>
</div>

<!-- é˜…è¯»è®¾ç½® -->
<div class="reading-settings">
<h3 style="margin-bottom: 15px; color: var(--primary-color);">ğŸ“– é˜…è¯»è®¾ç½®</h3>
<div class="setting-group">
<label class="setting-label">å­—ä½“å¤§å°</label>
<input type="range" class="slider" id="fontSize" min="12" max="24" value="16" oninput="updateFontSize(this.value)">
<small id="fontSizeValue">16px</small>
</div>
<div class="setting-group">
<label class="setting-label">è¡Œé—´è·</label>
<input type="range" class="slider" id="lineHeight" min="1.4" max="2.5" step="0.1" value="1.8" oninput="updateLineHeight(this.value)">
<small id="lineHeightValue">1.8</small>
</div>
<div class="setting-group">
<label class="setting-label">è‡ªåŠ¨æ»šåŠ¨é€Ÿåº¦</label>
<input type="range" class="slider" id="scrollSpeed" min="1" max="10" value="3" oninput="updateScrollSpeed(this.value)">
<small id="scrollSpeedValue">ä¸­ç­‰</small>
</div>
<div class="setting-group">
<label class="setting-label">å­—ä½“é¢œè‰²</label>
<input type="color" class="setting-input" id="textColor" value="#334155" onchange="updateTextColor(this.value)">
</div>
<div class="setting-group">
<label class="setting-label">èƒŒæ™¯é¢œè‰²</label>
<input type="color" class="setting-input" id="backgroundColor" value="#ffffff" onchange="updateBackgroundColor(this.value)">
</div>
</div>

<!-- æœç´¢åŠŸèƒ½ -->
<div class="reading-settings">
<h3 style="margin-bottom: 15px; color: var(--primary-color);">ğŸ” æœç´¢æ–‡æœ¬</h3>
<div class="setting-group">
<label class="setting-label">æœç´¢å†…å®¹</label>
<input type="text" class="setting-input" id="searchInput" placeholder="è¾“å…¥è¦æœç´¢çš„è¯..." oninput="performSearch()">
<div class="search-result-info" id="searchResultInfo"></div>
</div>
<div class="setting-group" style="display: flex; gap: 10px;">
<button class="control-btn" style="flex: 1; justify-content: center;" onclick="goToPrevMatch()">â—€ ä¸Šä¸€ä¸ª</button>
<button class="control-btn" style="flex: 1; justify-content: center;" onclick="goToNextMatch()">ä¸‹ä¸€ä¸ª â–¶</button>
</div>
</div>

<!-- é˜…è¯»å†å² -->
<div class="reading-settings">
<h3 style="margin-bottom: 15px; color: var(--primary-color);">ğŸ“š é˜…è¯»å†å²</h3>
<div id="readingHistoryList">
<!-- å†å²é¡¹å°†åŠ¨æ€æ’å…¥ -->
</div>
<div class="setting-group">
<button class="control-btn" style="width: 100%; justify-content: center;" onclick="clearHistory()">
ğŸ—‘ï¸ æ¸…é™¤å†å²
</button>
</div>
</div>

<!-- å¿«é€Ÿè·³è½¬ -->
<div class="reading-settings">
<h3 style="margin-bottom: 15px; color: var(--primary-color);">ğŸ¯ å¿«é€Ÿè·³è½¬</h3>
<div class="setting-group">
<label class="setting-label">è·³è½¬åˆ°ç™¾åˆ†æ¯”</label>
<input type="number" class="setting-input" id="jumpPercent" min="0" max="100" placeholder="è¾“å…¥0-100" onchange="jumpToPercent(this.value)">
</div>
<div class="setting-group">
<button class="control-btn" style="width: 100%; justify-content: center;" onclick="jumpToTop()">
â¬†ï¸ è·³è½¬åˆ°å¼€å¤´
</button>
</div>
<div class="setting-group">
<button class="control-btn" style="width: 100%; justify-content: center;" onclick="jumpToEnd()">
â¬‡ï¸ è·³è½¬åˆ°ç»“å°¾
</button>
</div>
</div>
</div>

<!-- é˜…è¯»åŒºåŸŸ -->
<div class="reading-area" id="readingArea">
<div class="reader-container">
<div class="empty-state" id="emptyState">
<div class="empty-icon">ğŸ“–</div>
<h3>æ¬¢è¿ä½¿ç”¨EasyReader</h3>
<p style="margin-top: 10px;">ç‚¹å‡»å·¦ä¾§è®¾ç½®æŒ‰é’®ä¸Šä¼ æ‚¨çš„TXTæ–‡ä»¶å¼€å§‹é˜…è¯»</p>
<p style="margin-top: 5px; font-size: 14px;">æ”¯æŒå¤šç§ç¼–ç æ ¼å¼ï¼šUTF-8ã€GBKã€GB2312ã€Big5ç­‰</p>
</div>
<div id="contentArea" style="display: none;">
<h1 class="chapter-title" id="chapterTitle">æ–‡æ¡£å†…å®¹</h1>
<div class="text-content" id="textContent"></div>
</div>
</div>
</div>
</div>

<!-- åº•éƒ¨è¿›åº¦æ¡ -->
<div class="progress-container" id="progressContainer" style="display: none;">
<div class="progress-info">
<span id="currentPage">0</span>/<span id="totalPages">0</span>
</div>
<div class="progress-bar" onclick="jumpToPosition(event)">
<div class="progress-fill" id="progressFill"></div>
</div>
<div class="progress-info">
<span id="readingProgress">0%</span>
</div>
</div>

<!-- è‡ªå®šä¹‰â€œç»§ç»­é˜…è¯»â€æç¤ºæ¡† -->
<div class="resume-modal" id="resumeModal" style="display: none;">
<div class="resume-modal-content">
<button class="resume-close-btn" onclick="closeResumeModal()">&times;</button>
<h3 style="margin: 0 0 12px; color: var(--primary-color);">ğŸ“– ç»§ç»­é˜…è¯»ï¼Ÿ</h3>
<p style="color: var(--text-light); margin-bottom: 20px; font-size: 14px;">
æ£€æµ‹åˆ°æ‚¨ä¸Šæ¬¡é˜…è¯»åˆ° <strong id="resumePercent">0%</strong>ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ
</p>
<div style="display: flex; gap: 10px; justify-content: flex-end;">
<button class="control-btn" style="padding: 6px 12px; font-size: 14px;" onclick="closeResumeModal()">
ä»å¤´å¼€å§‹
</button>
<button class="control-btn" style="background: var(--primary-color); color: white; padding: 6px 12px; font-size: 14px;" onclick="confirmResume()">
ç»§ç»­é˜…è¯»
</button>
</div>
</div>
</div>

<!-- æç¤ºç”¨æˆ·é‡æ–°é€‰æ‹©æ–‡ä»¶ -->
<div class="resume-modal" id="selectFileModal" style="display: none;">
<div class="resume-modal-content">
<button class="resume-close-btn" onclick="closeSelectFileModal()">&times;</button>
<h3 style="margin: 0 0 12px; color: var(--primary-color);">ğŸ“ è¯·é‡æ–°é€‰æ‹©æ–‡ä»¶</h3>
<p style="color: var(--text-light); margin-bottom: 20px; font-size: 14px;">
ä¸ºäº†ç»§ç»­é˜…è¯»ä¸Šæ¬¡è¿›åº¦ï¼Œè¯·é‡æ–°é€‰æ‹©æ–‡ä»¶ï¼š<br>
<strong id="fileNameToSelect"></strong>
</p>
<button class="control-btn" style="background: var(--primary-color); color: white; width: 100%;" onclick="closeSelectFileModal()">
çŸ¥é“äº†
</button>
</div>
</div>

<!-- æ¸…é™¤å†å²ç¡®è®¤æ¡† -->
<div class="resume-modal" id="clearHistoryModal" style="display: none;">
<div class="resume-modal-content">
<button class="resume-close-btn" onclick="closeClearHistoryModal()">&times;</button>
<h3 style="margin: 0 0 12px; color: var(--primary-color);">ğŸ—‘ï¸ æ¸…é™¤é˜…è¯»å†å²ï¼Ÿ</h3>
<p style="color: var(--text-light); margin-bottom: 20px; font-size: 14px;">
æ­¤æ“ä½œå°†æ¸…é™¤æ‰€æœ‰é˜…è¯»è®°å½•ï¼Œæ— æ³•æ¢å¤ã€‚
</p>
<div style="display: flex; gap: 10px; justify-content: flex-end;">
<button class="control-btn" style="padding: 6px 12px; font-size: 14px;" onclick="closeClearHistoryModal()">
å–æ¶ˆ
</button>
<button class="control-btn" style="background: var(--error-color); color: white; padding: 6px 12px; font-size: 14px;" onclick="confirmClearHistory()">
ç¡®å®šæ¸…é™¤
</button>
</div>
</div>
</div>

<script>
// å…¨å±€å˜é‡
let currentText = '';
let currentFile = null;
let currentEncoding = '';
let autoScrollInterval = null;
let autoScrollSpeed = 3;
let isAutoScrolling = false;
let totalWords = 0;
let searchMatches = [];
let currentMatchIndex = -1;

// å­˜å‚¨å¾…æ¢å¤çš„è¿›åº¦
window.pendingResumeProgress = null;

// æ”¯æŒçš„ç¼–ç æ˜ å°„è¡¨
const ENCODING_MAP = {
'UTF-8': 'utf-8',
'GBK': 'gbk',
'GB2312': 'gb2312',
'GB18030': 'gb18030',
'Big5': 'big5',
'UTF-16LE': 'utf-16le',
'UTF-16BE': 'utf-16be',
'Shift_JIS': 'shift_jis',
'EUC-KR': 'euc-kr',
'ISO-8859-1': 'iso-8859-1',
'Windows-1252': 'windows-1252'
};

// åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
loadUserSettings();
loadReadingHistory();
setupEventListeners();
setupDragAndDrop();
});

// è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
function setupEventListeners() {
window.addEventListener('scroll', debounce(updateReadingProgress, 300));
document.addEventListener('keydown', handleKeyboardShortcuts);
document.addEventListener('click', function(e) {
if (isAutoScrolling && !e.target.closest('.navbar') && !e.target.closest('.sidebar')) {
toggleAutoScroll();
}
});
}

// é˜²æŠ–å‡½æ•°
function debounce(func, delay) {
let timer;
return function() {
const context = this, args = arguments;
clearTimeout(timer);
timer = setTimeout(() => func.apply(context, args), delay);
};
}

// è®¾ç½®æ‹–æ‹½ä¸Šä¼ åŠŸèƒ½
function setupDragAndDrop() {
const fileUpload = document.querySelector('.file-upload');
fileUpload.addEventListener('dragover', (e) => {
e.preventDefault();
fileUpload.style.borderColor = 'var(--primary-color)';
fileUpload.style.background = 'rgba(79, 70, 229, 0.1)';
});
fileUpload.addEventListener('dragleave', (e) => {
e.preventDefault();
fileUpload.style.borderColor = 'var(--border-light)';
fileUpload.style.background = 'transparent';
});
fileUpload.addEventListener('drop', (e) => {
e.preventDefault();
fileUpload.style.borderColor = 'var(--border-light)';
fileUpload.style.background = 'transparent';
const files = e.dataTransfer.files;
if (files.length > 0) {
loadFileContent(files[0]);
}
});
}

// åˆ‡æ¢ä¾§è¾¹æ 
function toggleSidebar() {
const sidebar = document.getElementById('sidebar');
const readingArea = document.getElementById('readingArea');
sidebar.classList.toggle('open');
readingArea.classList.toggle('sidebar-open');
}

// åŠ è½½æ–‡ä»¶
function loadFile(event) {
const file = event.target.files[0];
if (file) {
loadFileContent(file);
}
}

// ç”Ÿæˆæ–‡ä»¶æŒ‡çº¹ï¼ˆè½»é‡é‡‡æ ·ï¼‰
async function generateFileFingerprint(file) {
const headSize = Math.min(file.size, 512);
const tailSize = Math.min(file.size, 512);
const head = file.slice(0, headSize);
const tail = file.size > 512 ? file.slice(file.size - tailSize, file.size) : head;

const [headBuf, tailBuf] = await Promise.all([
readFileAsArrayBuffer(head),
readFileAsArrayBuffer(tail)
]);

const headHex = Array.from(new Uint8Array(headBuf)).slice(0, 8).map(b => b.toString(16).padStart(2, '0')).join('');
const tailHex = Array.from(new Uint8Array(tailBuf)).slice(-8).map(b => b.toString(16).padStart(2, '0')).join('');
return `${file.name}_${file.size}_${file.lastModified}_${headHex}_${tailHex}`;
}

function readFileAsArrayBuffer(blob) {
return new Promise((resolve, reject) => {
const reader = new FileReader();
reader.onload = () => resolve(reader.result);
reader.onerror = reject;
reader.readAsArrayBuffer(blob);
});
}

// è¯»å–æ–‡ä»¶å†…å®¹
async function loadFileContent(file) {
if (!file.type.includes('text') && !file.name.toLowerCase().endsWith('.txt')) {
showNotification('è¯·é€‰æ‹©TXTæ ¼å¼çš„æ–‡ä»¶ï¼', 'error');
return;
}

showLoadingMessage();

// ç”ŸæˆæŒ‡çº¹
const fingerprint = await generateFileFingerprint(file);
const history = getHistory();
const record = history[fingerprint];

currentFile = file;
try {
const result = await detectBestEncoding(file);
if (result) {
currentText = result.text;
currentEncoding = result.encoding;
displayContent(currentText, file.name, result.encoding);
updateEncodingStatus(result.encoding, result.confidence);
document.getElementById('progressContainer').style.display = 'flex';
updateTotalWords();
updateReadingProgress();

// æ¢å¤é˜…è¯»ä½ç½® - ä½¿ç”¨è‡ªå®šä¹‰ UI æç¤º
if (record && record.progress > 0) {
setTimeout(() => {
const modal = document.getElementById('resumeModal');
const percentSpan = document.getElementById('resumePercent');
percentSpan.textContent = `${Math.round(record.progress)}%`;
modal.style.display = 'flex';
window.pendingResumeProgress = record.progress;
}, 500);
}

// é‡ç½®æœç´¢
searchMatches = [];
currentMatchIndex = -1;
document.getElementById('searchInput').value = '';
document.getElementById('searchResultInfo').textContent = '';
} else {
showEncodingSelector();
}
} catch (error) {
console.error('è¯»å–æ–‡ä»¶å¤±è´¥:', error);
showNotification('è¯»å–æ–‡ä»¶å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
hideLoadingMessage();
}
}

// ä¿å­˜é˜…è¯»è¿›åº¦
function updateReadingProgress() {
if (!currentText || !currentFile) return;

const scrollTop = window.scrollY;
const scrollHeight = document.body.scrollHeight - window.innerHeight;
const progress = scrollHeight > 0 ? (scrollTop / scrollHeight) * 100 : 0;

document.getElementById('progressFill').style.width = progress + '%';
document.getElementById('readingProgress').textContent = Math.round(progress) + '%';

const currentCharPos = Math.round((currentText.length * progress) / 100);
const currentPage = Math.max(1, Math.ceil(currentCharPos / 1000));
const totalPages = Math.ceil(currentText.length / 1000);
document.getElementById('currentPage').textContent = currentPage;
document.getElementById('totalPages').textContent = totalPages;

// ä¿å­˜è¿›åº¦
if (currentFile) {
generateFileFingerprint(currentFile).then(fingerprint => {
saveReadingProgress(fingerprint, Math.round(progress));
});
}
}

// ä¿å­˜è¿›åº¦åˆ° localStorage
function saveReadingProgress(fingerprint, progress) {
const history = getHistory();
history[fingerprint] = {
filename: currentFile.name,
progress,
lastOpenTime: new Date().toISOString()
};
localStorage.setItem('readingHistory', JSON.stringify(history));
renderReadingHistory();
}

// è·å–å†å²è®°å½•
function getHistory() {
return JSON.parse(localStorage.getItem('readingHistory') || '{}');
}

// æ¸²æŸ“å†å²åˆ—è¡¨
function renderReadingHistory() {
const list = document.getElementById('readingHistoryList');
const history = Object.values(getHistory())
.sort((a, b) => new Date(b.lastOpenTime) - new Date(a.lastOpenTime))
.slice(0, 10);

list.innerHTML = history.map(item => `
<div class="history-item" onclick="loadHistoryFile('${encodeURIComponent(item.filename)}', ${item.progress})">
<div class="history-filename">${item.filename}</div>
<div class="history-progress">è¿›åº¦ ${item.progress}% Â· ${formatTimeAgo(item.lastOpenTime)}</div>
</div>
`).join('');
}

// åŠ è½½å†å²æ–‡ä»¶ï¼ˆå¼¹å‡ºæç¤ºï¼‰
function loadHistoryFile(filename, progress) {
const modal = document.getElementById('selectFileModal');
const nameSpan = document.getElementById('fileNameToSelect');
nameSpan.textContent = decodeURIComponent(filename);
modal.style.display = 'flex';
window.pendingResumeProgress = progress;
}

// æ¸…é™¤å†å² - å¼¹å‡ºç¡®è®¤æ¡†
function clearHistory() {
document.getElementById('clearHistoryModal').style.display = 'flex';
}

// æ—¶é—´æ ¼å¼åŒ–
function formatTimeAgo(isoString) {
const now = new Date();
const past = new Date(isoString);
const diffInHours = (now - past) / 1000 / 60 / 60;
if (diffInHours < 1) return 'åˆšåˆš';
if (diffInHours < 24) return `${Math.floor(diffInHours)}å°æ—¶å‰`;
return `${Math.floor(diffInHours / 24)}å¤©å‰`;
}

// åŠ è½½å†å²
function loadReadingHistory() {
renderReadingHistory();
}

// å¢å¼ºçš„ç¼–ç æ£€æµ‹
async function detectBestEncoding(file) {
const encodings = [
'UTF-8', 'GBK', 'GB2312', 'GB18030', 'Big5', 'UTF-16LE', 'UTF-16BE',
'Shift_JIS', 'EUC-KR', 'ISO-8859-1', 'Windows-1252'
];
let bestResult = null;
let bestScore = -1;
const sampleSize = Math.min(file.size, 8192);
const sampleBlob = file.slice(0, sampleSize);

for (let encoding of encodings) {
try {
const result = await readFileWithEncoding(sampleBlob, encoding, true);
if (result) {
const score = calculateEncodingScore(result, encoding);
if (score > bestScore) {
bestScore = score;
bestResult = { text: result, encoding: encoding, confidence: score };
}
}
} catch (error) {
continue;
}
}

if (bestResult && bestScore > 50) {
try {
const fullText = await readFileWithEncoding(file, bestResult.encoding);
return { text: fullText, encoding: bestResult.encoding, confidence: bestScore };
} catch (error) {
return null;
}
}
return null;
}

// ä½¿ç”¨æŒ‡å®šç¼–ç è¯»å–æ–‡ä»¶
async function readFileWithEncoding(file, encoding, isSample = false) {
return new Promise((resolve, reject) => {
const reader = new FileReader();
reader.onload = function(e) {
try {
const result = e.target.result;
if (encoding === 'UTF-8') {
resolve(result);
} else {
const buffer = new Uint8Array(result);
const decoder = new TextDecoder(ENCODING_MAP[encoding] || encoding, { fatal: false });
const text = decoder.decode(buffer);
resolve(text);
}
} catch (error) {
reject(error);
}
};
reader.onerror = () => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
if (encoding === 'UTF-8') {
reader.readAsText(file, 'UTF-8');
} else {
reader.readAsArrayBuffer(file);
}
});
}

// æ”¹è¿›çš„ç¼–ç è´¨é‡è¯„åˆ†ç®—æ³•
function calculateEncodingScore(text, encoding) {
if (!text || text.length === 0) return -1;
let score = 0;
let totalChars = Math.min(text.length, 2000);
let chineseCount = 0;
let invalidCharCount = 0;

for (let i = 0; i < totalChars; i++) {
const char = text[i];
const code = char.charCodeAt(0);
if (char === '' || char === '\uFFFD') {
invalidCharCount++;
score -= 10;
}
if ((code >= 0x4e00 && code <= 0x9fff)) {
chineseCount++;
score += 3;
}
}

if (['GBK', 'GB2312', 'GB18030'].includes(encoding)) {
if (chineseCount > totalChars * 0.3) score += 20;
} else if (encoding === 'Big5') {
if (chineseCount > totalChars * 0.3) score += 15;
} else if (encoding === 'UTF-8') {
score += 10;
if (chineseCount > 0) score += 10;
}

const invalidRatio = invalidCharCount / totalChars;
if (invalidRatio > 0.1) score -= invalidRatio * 100;
const coherenceScore = checkTextCoherence(text.substring(0, 500));
score += coherenceScore;
return Math.max(0, score);
}

function checkTextCoherence(text) {
let score = 0;
const commonWords = ['çš„', 'äº†', 'åœ¨', 'æ˜¯', 'æœ‰', 'æˆ‘', 'ä½ ', 'ä»–', 'å¥¹', 'å®ƒ', 'è¿™', 'é‚£', 'å’Œ', 'ä¸'];
for (let word of commonWords) {
if (text.includes(word)) score += 2;
}
return score;
}

// æ‰‹åŠ¨é‡æ–°ç¼–ç 
async function reloadWithEncoding() {
const encoding = document.getElementById('manualEncoding').value;
if (!currentFile) {
showNotification('è¯·å…ˆé€‰æ‹©æ–‡ä»¶', 'warning');
return;
}
if (!encoding) {
loadFileContent(currentFile);
return;
}
showLoadingMessage();
try {
const text = await readFileWithEncoding(currentFile, encoding);
const quality = calculateEncodingScore(text, encoding);
currentText = text;
currentEncoding = encoding;
displayContent(currentText, currentFile.name, encoding);
updateEncodingStatus(encoding, quality);
updateTotalWords();
updateReadingProgress();
showNotification(`å·²ä½¿ç”¨ ${encoding} ç¼–ç é‡æ–°åŠ è½½`, 'success');
} catch (error) {
showNotification(`ä½¿ç”¨ ${encoding} ç¼–ç å¤±è´¥ï¼Œè¯·å°è¯•å…¶ä»–ç¼–ç `, 'error');
hideLoadingMessage();
}
}

// æ›´æ–°ç¼–ç çŠ¶æ€æ˜¾ç¤º
function updateEncodingStatus(encoding, confidence) {
const statusElement = document.getElementById('currentEncoding');
const nameElement = document.getElementById('encodingName');
statusElement.style.display = 'flex';
nameElement.textContent = encoding;
if (confidence >= 80) {
statusElement.className = 'encoding-status success';
statusElement.innerHTML = '<span>âœ…</span><span>' + encoding + ' (ä¼˜ç§€)</span>';
} else if (confidence >= 60) {
statusElement.className = 'encoding-status warning';
statusElement.innerHTML = '<span>âš ï¸</span><span>' + encoding + ' (è‰¯å¥½)</span>';
} else {
statusElement.className = 'encoding-status error';
statusElement.innerHTML = '<span>âŒ</span><span>' + encoding + ' (å¯èƒ½æœ‰è¯¯)</span>';
}
}

// æ˜¾ç¤ºåŠ è½½æ¶ˆæ¯
function showLoadingMessage() {
const emptyState = document.getElementById('emptyState');
emptyState.innerHTML = `
<div class="empty-icon"><div class="loading-spinner"></div></div>
<h3>æ­£åœ¨æ£€æµ‹æ–‡ä»¶ç¼–ç ...</h3>
<p style="margin-top: 10px;">æ­£åœ¨å°è¯•æœ€ä½³ç¼–ç æ ¼å¼ï¼Œè¯·ç¨å€™</p>
`;
}

// éšè—åŠ è½½æ¶ˆæ¯
function hideLoadingMessage() {
const emptyState = document.getElementById('emptyState');
emptyState.innerHTML = `
<div class="empty-icon">ğŸ“–</div>
<h3>æ¬¢è¿ä½¿ç”¨EasyReader</h3>
<p style="margin-top: 10px;">ç‚¹å‡»å·¦ä¾§è®¾ç½®æŒ‰é’®ä¸Šä¼ æ‚¨çš„TXTæ–‡ä»¶å¼€å§‹é˜…è¯»</p>
<p style="margin-top: 5px; font-size: 14px;">æ”¯æŒå¤šç§ç¼–ç æ ¼å¼ï¼šUTF-8ã€GBKã€GB2312ã€Big5ç­‰</p>
`;
}

// æ˜¾ç¤ºç¼–ç é€‰æ‹©å™¨
function showEncodingSelector() {
const emptyState = document.getElementById('emptyState');
emptyState.innerHTML = `
<div class="empty-icon">ğŸ”§</div>
<h3>æ— æ³•è‡ªåŠ¨è¯†åˆ«ç¼–ç </h3>
<p style="margin-top: 10px; margin-bottom: 20px;">è¯·åœ¨å·¦ä¾§è®¾ç½®é¢æ¿æ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶ç¼–ç æ ¼å¼</p>
<button onclick="toggleSidebar()" style="background: var(--primary-color); color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer;">
æ‰“å¼€ç¼–ç è®¾ç½®
</button>
`;
}

// æ˜¾ç¤ºå†…å®¹
function displayContent(text, fileName, encoding) {
document.getElementById('emptyState').style.display = 'none';
document.getElementById('contentArea').style.display = 'block';
const titleText = fileName || 'æ–‡æ¡£å†…å®¹';
const encodingInfo = encoding ? ` (${encoding})` : '';
document.getElementById('chapterTitle').textContent = titleText + encodingInfo;
document.getElementById('textContent').textContent = text;
if (window.innerWidth <= 768 && document.getElementById('sidebar').classList.contains('open')) {
toggleSidebar();
}
window.scrollTo(0, 0);
}

// æ˜¾ç¤ºé€šçŸ¥æ¶ˆæ¯
function showNotification(message, type = 'success') {
const existing = document.querySelector('.notification');
if (existing) existing.remove();
const notification = document.createElement('div');
notification.className = `notification ${type}`;
notification.textContent = message;
document.body.appendChild(notification);
setTimeout(() => notification.classList.add('show'), 100);
setTimeout(() => {
notification.classList.remove('show');
setTimeout(() => {
if (notification.parentNode) notification.parentNode.removeChild(notification);
}, 300);
}, 3000);
}

// æ›´æ–°å­—ä½“å¤§å°
function updateFontSize(size) {
document.getElementById('textContent').style.fontSize = size + 'px';
document.getElementById('fontSizeValue').textContent = size + 'px';
saveUserSettings();
}

// æ›´æ–°è¡Œé—´è·
function updateLineHeight(height) {
document.getElementById('textContent').style.lineHeight = height;
document.getElementById('lineHeightValue').textContent = height;
saveUserSettings();
}

// æ›´æ–°æ»šåŠ¨é€Ÿåº¦
function updateScrollSpeed(speed) {
autoScrollSpeed = parseInt(speed);
const speedText = ['ææ…¢','å¾ˆæ…¢','æ…¢','ä¸­ç­‰','å¿«','å¾ˆå¿«','æå¿«','é£å¿«','é—ªç”µ','å…‰é€Ÿ'];
document.getElementById('scrollSpeedValue').textContent = speedText[speed - 1] || 'ä¸­ç­‰';
if (isAutoScrolling) { stopAutoScroll(); startAutoScroll(); }
saveUserSettings();
}

// æ›´æ–°æ–‡å­—é¢œè‰²
function updateTextColor(color) {
document.getElementById('textContent').style.color = color;
saveUserSettings();
}

// æ›´æ–°èƒŒæ™¯é¢œè‰²
function updateBackgroundColor(color) {
document.getElementById('textContent').style.backgroundColor = color;
saveUserSettings();
}

// åˆ‡æ¢æ·±è‰²æ¨¡å¼
function toggleDarkMode() {
document.body.classList.toggle('dark');
saveUserSettings();
}

// åˆ‡æ¢å…¨å±æ¨¡å¼
function toggleFullscreen() {
if (!document.fullscreenElement) {
document.documentElement.requestFullscreen().catch(err => {
showNotification('æ— æ³•è¿›å…¥å…¨å±æ¨¡å¼', 'warning');
});
} else {
document.exitFullscreen();
}
}

// è‡ªåŠ¨æ»šåŠ¨åŠŸèƒ½
function toggleAutoScroll() {
if (isAutoScrolling) stopAutoScroll();
else startAutoScroll();
}

function startAutoScroll() {
if (!currentText) {
showNotification('è¯·å…ˆåŠ è½½æ–‡ä»¶', 'warning');
return;
}
isAutoScrolling = true;
document.getElementById('autoScrollIndicator').classList.add('active');
autoScrollInterval = setInterval(() => {
window.scrollBy(0, autoScrollSpeed);
if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 100) {
stopAutoScroll();
showNotification('å·²æ»šåŠ¨åˆ°æ–‡æ¡£æœ«å°¾', 'success');
}
}, 50);
}

function stopAutoScroll() {
isAutoScrolling = false;
document.getElementById('autoScrollIndicator').classList.remove('active');
if (autoScrollInterval) clearInterval(autoScrollInterval);
autoScrollInterval = null;
}

// è·³è½¬åŠŸèƒ½
function jumpToPercent(percent) {
if (!currentText || percent < 0 || percent > 100) return;
const targetPosition = (document.body.scrollHeight - window.innerHeight) * (percent / 100);
window.scrollTo({ top: targetPosition, behavior: 'smooth' });
showNotification(`å·²è·³è½¬åˆ° ${percent}%`, 'success');
}

function jumpToTop() {
window.scrollTo({ top: 0, behavior: 'smooth' });
showNotification('å·²è·³è½¬åˆ°æ–‡æ¡£å¼€å¤´', 'success');
}

function jumpToEnd() {
window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
showNotification('å·²è·³è½¬åˆ°æ–‡æ¡£æœ«å°¾', 'success');
}

function jumpToPosition(event) {
const progressBar = event.currentTarget;
const rect = progressBar.getBoundingClientRect();
const clickX = event.clientX - rect.left;
const percent = (clickX / rect.width) * 100;
jumpToPercent(Math.round(percent));
}

// ç»Ÿè®¡æ€»å­—æ•°
function updateTotalWords() {
if (currentText) {
totalWords = currentText.length;
}
}

// é”®ç›˜å¿«æ·é”®
function handleKeyboardShortcuts(event) {
if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT') return;
switch(event.key) {
case ' ': event.preventDefault(); toggleAutoScroll(); break;
case 'ArrowUp': event.preventDefault(); window.scrollBy(0, -100); break;
case 'ArrowDown': event.preventDefault(); window.scrollBy(0, 100); break;
case 'Home': event.preventDefault(); jumpToTop(); break;
case 'End': event.preventDefault(); jumpToEnd(); break;
case 'f': case 'F': if (!event.ctrlKey && !event.metaKey) { event.preventDefault(); toggleFullscreen(); } break;
case 'd': case 'D': event.preventDefault(); toggleDarkMode(); break;
case 's': case 'S': if (!event.ctrlKey && !event.metaKey) { event.preventDefault(); toggleSidebar(); } break;
}
}

// æ–‡æœ¬æœç´¢åŠŸèƒ½
function performSearch() {
const query = document.getElementById('searchInput').value.trim();
const contentEl = document.getElementById('textContent');
if (!query) {
contentEl.innerHTML = currentText;
searchMatches = [];
currentMatchIndex = -1;
document.getElementById('searchResultInfo').textContent = '';
return;
}

const regex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
const matches = [...currentText.matchAll(regex)];
searchMatches = matches;
currentMatchIndex = matches.length > 0 ? 0 : -1;

const highlightedText = currentText.replace(regex, match => `<mark class="highlight">${match}</mark>`);
contentEl.innerHTML = highlightedText;

document.getElementById('searchResultInfo').textContent = 
matches.length > 0 ? `æ‰¾åˆ° ${matches.length} ä¸ªåŒ¹é…é¡¹` : 'æœªæ‰¾åˆ°åŒ¹é…å†…å®¹';
}

function goToPrevMatch() {
if (searchMatches.length === 0) return;
currentMatchIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length;
scrollToCurrentMatch();
}

function goToNextMatch() {
if (searchMatches.length === 0) return;
currentMatchIndex = (currentMatchIndex + 1) % searchMatches.length;
scrollToCurrentMatch();
}

function scrollToCurrentMatch() {
const marks = document.querySelectorAll('.highlight, mark');
if (marks.length === 0) return;
const target = marks[currentMatchIndex];
target.scrollIntoView({ behavior: 'smooth', block: 'center' });
target.style.transition = 'all 0.3s';
target.style.transform = 'scale(1.1)';
setTimeout(() => { target.style.transform = 'scale(1)'; }, 300);
}

// ä¿å­˜ç”¨æˆ·è®¾ç½®
function saveUserSettings() {
const settings = {
fontSize: document.getElementById('fontSize').value,
lineHeight: document.getElementById('lineHeight').value,
scrollSpeed: document.getElementById('scrollSpeed').value,
textColor: document.getElementById('textColor').value,
backgroundColor: document.getElementById('backgroundColor').value,
isDarkMode: document.body.classList.contains('dark')
};
localStorage.setItem('userSettings', JSON.stringify(settings));
}

// åŠ è½½ç”¨æˆ·è®¾ç½®
function loadUserSettings() {
const saved = localStorage.getItem('userSettings');
if (saved) {
const settings = JSON.parse(saved);
document.getElementById('fontSize').value = settings.fontSize;
document.getElementById('lineHeight').value = settings.lineHeight;
document.getElementById('scrollSpeed').value = settings.scrollSpeed;
document.getElementById('textColor').value = settings.textColor;
document.getElementById('backgroundColor').value = settings.backgroundColor;
updateFontSize(settings.fontSize);
updateLineHeight(settings.lineHeight);
updateScrollSpeed(settings.scrollSpeed);
updateTextColor(settings.textColor);
updateBackgroundColor(settings.backgroundColor);
if (settings.isDarkMode) {
document.body.classList.add('dark');
}
}
}

// ç¡®è®¤ç»§ç»­é˜…è¯»
function confirmResume() {
if (window.pendingResumeProgress !== null) {
jumpToPercent(window.pendingResumeProgress);
}
closeResumeModal();
}

// å…³é—­â€œç»§ç»­é˜…è¯»â€æç¤ºæ¡†
function closeResumeModal() {
document.getElementById('resumeModal').style.display = 'none';
window.pendingResumeProgress = null;
}

// å…³é—­â€œè¯·é‡æ–°é€‰æ‹©æ–‡ä»¶â€æç¤ºæ¡†
function closeSelectFileModal() {
document.getElementById('selectFileModal').style.display = 'none';
}

// å…³é—­â€œæ¸…é™¤å†å²â€æç¤ºæ¡†
function closeClearHistoryModal() {
document.getElementById('clearHistoryModal').style.display = 'none';
}

// ç¡®è®¤æ¸…é™¤å†å²
function confirmClearHistory() {
localStorage.removeItem('readingHistory');
renderReadingHistory();
showNotification('é˜…è¯»å†å²å·²æ¸…é™¤', 'success');
closeClearHistoryModal();
}

// ç‚¹å‡»é®ç½©å…³é—­æ¨¡æ€æ¡†
document.getElementById('resumeModal')?.addEventListener('click', e => e.target === e.currentTarget && closeResumeModal());
document.getElementById('selectFileModal')?.addEventListener('click', e => e.target === e.currentTarget && closeSelectFileModal());
document.getElementById('clearHistoryModal')?.addEventListener('click', e => e.target === e.currentTarget && closeClearHistoryModal());
</script>
</body>
</html>



<script>
      
</script>
</body>
</html>
